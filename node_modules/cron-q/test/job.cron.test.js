// job.cron.test.js
var CronQ = require('..');

describe('Test Queues and Jobs: ', function(){
  this.timeout(15000);
  var testData = {a: 1, b:2};
  var queues;
  var spy, spy2;

  // before
  before(function(next){

    queues = new CronQ(null, 'cQ2:');
    spy = sinon.spy();
    spy2 = sinon.spy();
    var qP = function(data, done){
      spy(data);
      done();
    };
    var qP2 = function(data, done){
      spy2(data);
      done();
    };
    queues.createQueue("nonCronQueue", qP);
    expect(queues._QUEUES).to.have.property("nonCronQueue");

    queues.createQueue("cronQueue", qP);
    expect(queues._QUEUES).to.have.property("cronQueue");

    queues.createQueue("cronQueue2", qP2);

    queues.client.reset(function(err){
      next(err);
    });

  });



  it("validate default values", function(){

    expect(queues.client).to.be.a('object');
    expect(queues.redis_options).to.be.a('object');
    expect(queues.redis_options.host).to.equal('localhost');
    expect(queues.redis_options.port).to.equal('6379');
    expect(queues.redis_options.prefix).to.equal('cQ2:');

    expect(queues._QUEUES).to.be.a('object');
    expect(queues._CRON_JOBS).to.be.a('object');
    expect(queues.createQueue).to.be.a('function');

    expect(Object.keys(queues._QUEUES).length).to.equal(3);

  });



  it("validate non-cron jobs", function(next){

    queues.addJob("nonCronQueue", testData);
    queues.addJob("nonCronQueue", testData);
    setTimeout(function(){
      spy.should.have.callCount(2);
      spy.should.always.have.been.calledWithMatch(testData);
      next();
    },1000);

  });



  it("validate cron jobs", function(next){

    var jobId1, jobId2, jobId3;

    queues.addJob("cronQueue", testData, 3*1000, function(err, jobId){//job1
      expect(jobId).not.to.be.undefined();
      jobId1 = ""+jobId;
      expect(queues._CRON_JOBS).to.have.property(jobId1);
    }); // in 3 seconds

    var now = new Date();
    var future = new Date(now.getTime() + 5*1000);
    queues.addJob("cronQueue", testData, future, function(err, jobId){ //job2
      expect(jobId).not.to.be.undefined();
      jobId2 = ""+jobId;
      expect(queues._CRON_JOBS).to.have.property(jobId2);
    }); //in 5 seconds


    queues.addJob("cronQueue2", testData, 30*1000, function(err, jobId){ //job3
      expect(jobId).not.to.be.undefined();
      jobId3 = ""+jobId;
      expect(queues._CRON_JOBS).to.have.property(jobId3);
    }); //30 seconds

    setTimeout(function(){
      spy.should.have.callCount(2); //2 is from non-cron jobs
      spy2.should.have.callCount(0);
      expect(Object.keys(queues._CRON_JOBS).length).to.equal(3);
    },1000);


    setTimeout(function(){
      spy.should.have.callCount(3);
      spy.should.have.been.calledWithMatch(testData);

      expect(queues._CRON_JOBS).not.to.have.property(jobId1);
      expect(queues._CRON_JOBS).to.have.property(jobId2);
      expect(queues._CRON_JOBS).to.have.property(jobId3);

      queues.cancelJob(jobId2);
      expect(queues._CRON_JOBS).to.have.property(jobId2); //job2 still in memory if after cancelled
      spy2.should.have.callCount(0);
      queues.rescheduleJob(jobId3, future);
      queues.updateJobData(jobId3, {addNewData: true});
    }, 4000);

    setTimeout(function(){
      spy.should.have.callCount(3); //job1 + job3
      spy2.should.have.callCount(1);
      spy2.should.have.been.calledWithMatch({addNewData: true});

      expect(queues._CRON_JOBS).not.to.have.property(jobId1);
      expect(queues._CRON_JOBS).not.to.have.property(jobId2);
      expect(Object.keys(queues._CRON_JOBS).length).to.equal(0);
      next();
    }, 6000);

  });


/*
  it("validate high volumn job simultaneously ", function(next){

    var spy2 = sinon.spy();
    var qP2 = function(data, done){
      spy2(data);
      done();
    };
    queues.createQueue("highVolumnQueue", qP2);
    expect(queues._QUEUES).to.have.property("highVolumnQueue");
    var now = new Date();
    var future = new Date(now.getTime() + 5*1000);

    for(var i = 0; i < 100; i++){
      queues.addJob("highVolumnQueue", {c:i}, future); //job3
    }

    setTimeout(function(){
      spy2.should.have.callCount(100);
      expect(Object.keys(queues._CRON_JOBS).length).to.equal(0);
      next();
    }, 10000);
  });
*/
});
