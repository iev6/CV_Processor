// queue.js
// Replacement for kue/queue.js
var bullQueue = require('bull'),
    cron = require('cron');

var redis = require('./redis');

function defaultDone(err){
  if(err){
      console.log('Default callback method:', err);
    }
}

function assureFunc(done){
  if(typeof done == 'function'){
    return done;
  }else{
    return defaultDone;
  }
}
function Queues(redis_options, prefix){
  this._CRON_JOBS = {};
  this._QUEUES = {};
  this.client = redis.getClient(redis_options, prefix);
  this.redis_options = this.client.getRedisConfig();
}

// Queues internal methods
Queues.prototype = {
  // QUEUE RELATED METHODS
  _addToQueue: function(qName, data){
    var q = this._QUEUES[qName];
    if(q){
      q.add(data);
    }
  },

  // CRON JOB RELATED METHODS
  _putJobToCache: function(id, job){
    this._CRON_JOBS[""+id] = job;
  },
  _getJobFromCache: function(id){
    return this._CRON_JOBS[""+id];
  },
  _cronJob: function(jobData, cronTime){
    var id = jobData._id_;
    // create cron job and start it immediately
    var job = cron.job(cronTime, this._cronJobOnTick(id), this._cronJobOnComplete());
    job.start();
    this._putJobToCache(id, job);
    return job;
  },
  _cronTime: function(time){
    var isScheduleJob = false, jobRunAt = new Date();
    if(typeof time == 'number' && time > 0){
      isScheduleJob = true;
      jobRunAt.setTime(jobRunAt.getTime() + time);
    }else if(typeof time == 'object' && time.constructor == Date){
      if(time > jobRunAt){
        jobRunAt = time;
        isScheduleJob = true;
      }
    }
    if(isScheduleJob){
      return jobRunAt;
    }
    return undefined;
  },
  _cronJobOnTick: function(id){
    var jobId = id, self = this;
    return function(){
      self._getJob(jobId, function(err, jData){
        if(!err && jData){
          // PUT JOB DATA TO QUEUE, WAITING FOR PROCESSING
          self._addToQueue(jData._queue_, jData);
          delete self._CRON_JOBS[""+jobId];
        }
      });
    };
  },
  _cronJobOnComplete: function(){
    return function(){
      // job.onComplete()
      // NOTE: NOT THE RIGHT PLACE TO MARK JOB AS COMPLETED
      // AS IT WILL BE CALLED WHEN JOB STOPS
    };
  },

  // JOB PERSISTENCE
  _saveNewJob: function(jobData, timestamp, done){
    if(timestamp.constructor == Date){
      timestamp = timestamp.getTime();
    }
    return this.client.addCronJob(jobData, timestamp, done);
  },
  _getJob: function(jobId, done){
    return this.client.getJobData(jobId, done);
  },

  // UTILITY
  _logJobData: function(){
    if(process.env.LOG_JOB_DATA){
      console.log.apply(null, arguments);
    }
  },
  // WRAP ASSIGNED QUEUE PROCESSOR, TO ADD HOOK TO SYNC REDIS FOR SUCCESS/FAIL
  _wrapQueueProcessor: function(qProcessor){
    var self = this;
    return function(job, done){
      if(typeof qProcessor == 'function'){
        var jData = job.data; // bull queue job data
        var cronId = jData._id_; //assigned id
        var data = jData.data; // job assigned data
        var cancel = cronId? jData._cancel_: false;
        if(cancel){ // if job is cancelled then mark it as completed
          return self.client.onCronJobComplete(cronId, function(err){
            done(err);
          });
        }
        // Pass back the data and invoke queue processor
        qProcessor(data, function(err){
          if(err){
            if(cronId){
              // mark cron job as failed in Redis
              self.client.onCronJobFailed(cronId, err.message, function(error){
                done(error || err);
              });
            }else{
              done(err);
            }
          }else{
            if(cronId){
              // mark cron job as completed in Redis
              self.client.onCronJobComplete(cronId, function(err){
                done(err);
              });
            }else{
              done();
            }
          }
        });
      }
    };
  }
};

// Queues public methods
Queues.prototype.createQueue = function(qName, qProcessor){
  if(!this._QUEUES[qName]){
    var q = bullQueue(qName, this.redis_options.port, this.redis_options.host, this.redis_options);
    q.on('error', function(err){
      console.log('Error occurred for Queue:', qName);
      console.error('Error[', qName, "]:", err);
    });
    this._QUEUES[qName] = q;
    q.process(this._wrapQueueProcessor(qProcessor));
  }
  return this._QUEUES[qName];
};

Queues.prototype.addJob =
Queues.prototype.addJobToQueue = function(qName, data, when, done){
  if(qName && this._QUEUES[qName]){
    if(typeof when == 'function'){
      done = when;
      when = 0;
    }
    // put `data` under data field
    var jobData = {data: data, _queue_: qName};

    var cronTime = this._cronTime(when);
    if(cronTime){
      var self = this;
      this._saveNewJob(jobData, cronTime, function(err, jData){
        if(err){
          return assureFunc(done)(err);
        }
        self._cronJob(jData, cronTime);
        assureFunc(done)(null, jData._id_);
      });
    }else{
      this._addToQueue(qName, jobData);
      assureFunc(done)();
    }
  }else{
    assureFunc(done)(new Error("Unknown Queue["+qName+"]. Initialize the Queue first before adding job to it."));
  }
};

Queues.prototype.restore = function(){
  var self = this;
  this.client.getPendingJobs(function(err, jobs){
    if(err){
      console.error("Failed to restore jobs from Redis.\n", err);
    }else{
      for(var jobId in jobs){
        var job = jobs[jobId];

        var cronTime = job.time;
        if(typeof cronTime == 'string'){
          cronTime = parseInt(job.time, 10) || cronTime;
          cronTime = new Date(cronTime);
        }else if(typeof cronTime == 'number'){
          cronTime = new Date(cronTime);
        }

        cronTime = self._cronTime(cronTime);
        if(cronTime){
          self._cronJob(job.data, cronTime);
        }else{
          //mark JOB as completed in redis
          self.client.onCronJobComplete(jobId, function(err){
            if(!err){
              // trigger cron job onTick method
              self._cronJobOnTick(jobId)();
            }
          });
        }
      }
    }
  });
};

Queues.prototype.rescheduleJob = function(jobId, when, done){
  if(jobId){
    var cron_job = this._getJobFromCache(jobId);
    if(cron_job){
      var cronTime = this._cronTime(when);
      if(cronTime){
        //update JOB's schedule in redis
        this.client.updateJobTime(jobId, cronTime.getTime(), function(err){
          if(!err){
            cron_job.setTime(cron.time(cronTime));
            cron_job.start();
          }
          assureFunc(done)(err);
        });
      }else{
        //mark JOB as completed in redis
        this.client.onCronJobComplete(jobId, function(err){
          if(!err){
            cron_job.stop();
            // trigger cron job onTick method
            this._cronJobOnTick(jobId)();
          }
          assureFunc(done)(err);
        });
      }
    }else{
      assureFunc(done)(new Error("Can't find job by id:" +jobId));
    }
  }else{
    assureFunc(done)(new Error("job id is undefined."));
  }
};

Queues.prototype.cancelJob = function(jobId, done){
  this.client.updateJobData(jobId, {_cancel_:true}, done);
};

Queues.prototype.updateJobData = function(jobId, data, done){
  this.client.updateJobData(jobId, {data:data}, done);
};

Queues.prototype.restoreJob = function(jobId, done){
  this.client.updateJobData(jobId, {_cancel_:undefined}, done);
};

module.exports = Queues;